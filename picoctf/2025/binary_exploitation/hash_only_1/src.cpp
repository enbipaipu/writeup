#include "out.h" // このヘッダファイルの内容は不明

// グローバルオブジェクトの初期化関数（コンストラクタのようなもの）
int _init(EVP_PKEY_CTX *ctx) {
  int iVar1;

  // __gmon_start__ は、GNU Monitor (gprof) のための初期化関数です。
  // プロファイリング機能に関連しています。
  iVar1 = __gmon_start__();
  return iVar1;
}

// アドレス 0x0 の関数ポインタを呼び出す関数
// これは通常、NULLポインタデリファレンスのため、クラッシュを引き起こします。
void FUN_00101020(void) {
  (*(code *)(undefined *)0x0)();
  return;
}

// C++ の終了処理関数
void __cxa_finalize(void) {
  __cxa_finalize(__dso_handle); // __dso_handle はダイナミック共有オブジェクトのハンドル
  return;
}

// std::string クラスの c_str() メソッド
// 文字列の内容へのヌル終端されたポインタを返します。
// Ghidra は呼び出し規約やパラメータの格納方法を特定できていない可能性があります。
void std::string::c_str(void) {
  c_str(); // 実際には this ポインタが必要ですが、Ghidra の出力では省略されています。
  return;
}

// std::string クラスのデストラクタ
// オブジェクトが破棄される際に呼び出され、メモリなどを解放します。
// Ghidra は this ポインタを明示的に示しています。
void __thiscall std::string::~string(string *this) {
  ~string(this);
  return;
}

// sleep 関数
// 指定された秒数だけ実行を一時停止します。
// Ghidra は呼び出し規約やパラメータの格納方法を特定できていない可能性があります。
uint sleep(uint __seconds) {
  uint uVar1;
  uVar1 = sleep(__seconds);
  return uVar1;
}

// system 関数
// シェルコマンドを実行します。
// Ghidra は呼び出し規約やパラメータの格納方法を特定できていない可能性があります。
int system(char *__command) {
  int iVar1;
  iVar1 = system(__command);
  return iVar1;
}

// C++ の終了処理に関数を登録する関数
void __cxa_atexit(void) {
  __cxa_atexit();
  return;
}

// std::ostream クラスの operator<<
// 文字列を出力ストリームに挿入します。
// Ghidra は呼び出し規約やパラメータの格納方法を特定できていない可能性があります。
ostream * std::operator<<(ostream *param_1, char *param_2) {
  ostream *poVar1;
  poVar1 = operator<<(param_1, param_2);
  return poVar1;
}

// std::ostream クラスの operator<<
// 関数ポインタを出力ストリームに挿入します。
// Ghidra は this ポインタを明示的に示しています。
void __thiscall std::ostream::operator<<(ostream *this, _func_ostream_ptr_ostream_ptr *param_1) {
  operator<<(this, param_1);
  return;
}

// std::allocator<char> クラスのデストラクタ
// char 型のアロケータオブジェクトが破棄される際に呼び出されます。
// Ghidra は this ポインタを明示的に示しています。
void __thiscall std::allocator<char>::~allocator(allocator<char> *this) {
  ~allocator(this);
  return;
}

// スタック破壊を検出した場合に呼び出される関数
// 通常、プログラムを異常終了させます。
void __stack_chk_fail(void) {
  // WARNING: Subroutine does not return
  __stack_chk_fail();
}

// std::string クラスのコンストラクタ
// char ポインタから std::string オブジェクトを初期化します。
// Ghidra は this ポインタとアロケータを明示的に示しています。
void __thiscall std::string::string(string *this, char *param_1, allocator *param_2) {
  string(this, param_1, param_2);
  return;
}

// std::ios_base::Init クラスのコンストラクタ
// 標準入出力ストリーム (std::cin, std::cout, std::cerr, std::clog) を初期化します。
// Ghidra は this ポインタを明示的に示しています。
void __thiscall std::ios_base::Init::Init(Init *this) {
  Init(this);
  return;
}

// std::ostream クラスの operator<<
// 整数値を出力ストリームに挿入します。
// Ghidra は this ポインタを明示的に示しています。
void __thiscall std::ostream::operator<<(ostream *this, int param_1) {
  operator<<(this, param_1);
  return;
}

// 例外処理後の処理を再開する関数
void _Unwind_Resume(void) {
  // WARNING: Subroutine does not return
  _Unwind_Resume();
}

// std::allocator<char> クラスのデフォルトコンストラクタ
// Ghidra は呼び出し規約やパラメータの格納方法を特定できていない可能性があります。
void std::allocator<char>::allocator(void) {
  allocator();
  return;
}

// setgid 関数
// プロセスの実効グループ ID を設定します。
// Ghidra は呼び出し規約やパラメータの格納方法を特定できていない可能性があります。
int setgid(__gid_t __gid) {
  int iVar1;
  iVar1 = setgid(__gid);
  return iVar1;
}

// setuid 関数
// プロセスの実効ユーザー ID を設定します。
// Ghidra は呼び出し規約やパラメータの格納方法を特定できていない可能性があります。
int setuid(__uid_t __uid) {
  int iVar1;
  iVar1 = setuid(__uid);
  return iVar1;
}

// プログラムのエントリーポイント
void processEntry _start(undefined8 param_1, undefined8 param_2) {
  undefined1 auStack_8[8];

  // __libc_start_main は、C/C++ プログラムの初期化と終了処理を行う重要な関数です。
  // main 関数を呼び出し、exit システムコールを処理します。
  __libc_start_main(main, param_2, &stack0x00000008, __libc_csu_init, __libc_csu_fini, param_1, auStack_8);

  // 無限ループ
  do {
    // WARNING: Do nothing block with infinite loop
  } while (true);
}

// スレッドローカルストレージ (TLS) のクローンを登録解除する関数
// 実際には空の関数のようです。
// WARNING: Removing unreachable block (ram,0x00101283)
// WARNING: Removing unreachable block (ram,0x0010128f)
void deregister_tm_clones(void) {
  return;
}

// スレッドローカルストレージ (TLS) のクローンを登録する関数
// 実際には空の関数のようです。
// WARNING: Removing unreachable block (ram,0x001012c4)
// WARNING: Removing unreachable block (ram,0x001012d0)
void register_tm_clones(void) {
  return;
}

// グローバルデストラクタの補助関数
void __do_global_dtors_aux(void) {
  // completed_8061 はグローバルなフラグ変数
  if (completed_8061 != '\0') {
    return;
  }
  __cxa_finalize(__dso_handle); // グローバルオブジェクトのデストラクタを呼び出す
  deregister_tm_clones();
  completed_8061 = 1;
  return;
}

// フレームダミー関数
// コンパイラやリンカによって挿入されることがあります。
void frame_dummy(void) {
  register_tm_clones();
  return;
}

// メイン関数
bool main(void) {
  ostream *poVar1;
  char *__command;
  long in_FS_OFFSET;
  bool bVar2;
  allocator local_4d;
  int local_4c;
  string local_48[40]; // std::string オブジェクトを格納する配列
  long local_20;

  local_20 = *(long *)(in_FS_OFFSET + 0x28); // スタックガードの値を取得

  // 標準出力にメッセージを出力
  poVar1 = std::operator<<((ostream *)std::cout, "Computing the MD5 hash of /root/flag.txt.... ");
  poVar1 = (ostream *)std::ostream::operator<<(poVar1, std::endl<char, std::char_traits<char>>);
  std::ostream::operator<<(poVar1, std::endl<char, std::char_traits<char>>);
  sleep(2); // 2秒間スリープ

  // std::string オブジェクトの構築
  std::allocator<char>::allocator(); // デフォルトアロケータの構築 (通常は最適化で省略される)
  // try {
  std::string::string(local_48, "/bin/bash -c \'md5sum /root/flag.txt\'", &local_4d);
  std::allocator<char>::~allocator((allocator<char> *)&local_4d); // アロケータの破棄

  // 権限昇格
  setgid(0); // グループ ID を 0 (root) に設定
  setuid(0); // ユーザー ID を 0 (root) に設定

  // シェルコマンドの実行
  __command = (char *)std::string::c_str(); // std::string の内容を C スタイルの文字列として取得
  // try {
  local_4c = system(__command); // シェルコマンドを実行し、その終了ステータスを取得
  bVar2 = local_4c != 0; // 終了ステータスが 0 でない場合、エラーが発生

  // エラー処理
  if (bVar2) {
    poVar1 = std::operator<<((ostream *)std::cerr, "Error: system() call returned non-zero value: ");
    poVar1 = (ostream *)std::ostream::operator<<(poVar1, local_4c);
    std::ostream::operator<<(poVar1, std::endl<char, std::char_traits<char>>);
  }

  // std::string オブジェクトの破棄
  std::string::~string(local_48);

  // スタックガードのチェック
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return bVar2; // エラーが発生したかどうかを返す
  }
  // WARNING: Subroutine does not return
  __stack_chk_fail(); // スタックが破壊されている場合、エラー処理を呼び出す
}

// 静的初期化と破棄の制御関数
void __static_initialization_and_destruction_0(int param_1, int param_2) {
  if ((param_1 == 1) && (param_2 == 0xffff)) {
    std::ios_base::Init::Init((Init *)&std::__ioinit); // 標準入出力ストリームの初期化
    __cxa_atexit(std::ios_base::Init::~Init, &std::__ioinit, &__dso_handle); // 終了時の破棄関数を登録
  }
  return;
}

// グローバルオブジェクトの初期化を行う関数
void _GLOBAL__sub_I_main(void) {
  __static_initialization_and_destruction_0(1, 0xffff);
  return;
}

// C ライブラリの初期化関数
void __libc_csu_init(EVP_PKEY_CTX *param_1, undefined8 param_2, undefined8 param_3) {
  long lVar1;

  _init(param_1); // 最初の初期化関数を呼び出す
  lVar1 = 0;
  do {
    // __frame_dummy_init_array_entry は関数ポインタの配列
    (*(code *)(&__frame_dummy_init_array_entry)[lVar1])((ulong)param_1 & 0xffffffff, param_2, param_3);
    lVar1 = lVar1 + 1;
  } while (lVar1 != 2);
  return;
}

// C ライブラリの終了処理関数
void __libc_csu_fini(void) {
  return;
}

// プログラム終了時の処理関数
void _fini(void) {
  return;
}